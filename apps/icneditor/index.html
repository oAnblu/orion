<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ICN Editor</title>
<style>
body { margin:0; font-family:sans-serif; height:100vh; display:flex; }
#left { width:40%; border-right:1px solid #ccc; display:flex; flex-direction:column; }
#right { flex:1; display:flex; align-items:center; justify-content:center; background:#fafafa; }
#code { flex:1; width:100%; border:0; font-family:monospace; font-size:14px; padding:10px; outline:none; }
#c { width:300px; height:300px; }
#topbar { padding:6px; border-bottom:1px solid #ccc; display:flex; gap:6px; }
button { padding:4px 10px; }
</style>
</head>
<body>
<div id="left">
<div id="topbar">
<button id="run">Run</button>
<button id="clear">Clear</button>
</div>
<textarea id="code">c #8b4513 w 2 line -13 -3 13 3</textarea>
</div>
<div id="right">
<canvas id="c" width="300" height="300"></canvas>
</div>

<script>
function renderICN(code, canvas) {
const ctx = canvas.getContext('2d');
ctx.clearRect(0,0,canvas.width,canvas.height);
ctx.save();
ctx.translate(canvas.width/2, canvas.height/2);
ctx.lineCap='round';
let last={x:0,y:0};
const cmds=code.trim().split(/\s+/);
let color='#000', weight=1;
for(let i=0;i<cmds.length;i++){
const cmd=cmds[i];
if(cmd==='c') color=cmds[++i];
else if(cmd==='w') weight=parseFloat(cmds[++i]);
else if(cmd==='line'){
const x1=parseFloat(cmds[++i]),y1=parseFloat(cmds[++i]),x2=parseFloat(cmds[++i]),y2=parseFloat(cmds[++i]);
ctx.beginPath(); ctx.strokeStyle=color; ctx.lineWidth=weight;
ctx.moveTo(x1,-y1); ctx.lineTo(x2,-y2); ctx.stroke(); last={x:x2,y:y2};
}
else if(cmd==='cont'){
const x=parseFloat(cmds[++i]),y=parseFloat(cmds[++i]);
ctx.beginPath(); ctx.strokeStyle=color; ctx.lineWidth=weight;
ctx.moveTo(last.x,-last.y); ctx.lineTo(x,-y); ctx.stroke(); last={x,y};
}
else if(cmd==='square'){
const x=parseFloat(cmds[++i]),y=parseFloat(cmds[++i]),w=parseFloat(cmds[++i]),h=parseFloat(cmds[++i]);
ctx.beginPath(); ctx.strokeStyle=color; ctx.lineWidth=weight;
ctx.strokeRect(x-w/2,-y-h/2,w,h);
}
else if(cmd==='dot'){
const x=parseFloat(cmds[++i]),y=parseFloat(cmds[++i]);
ctx.beginPath(); ctx.fillStyle=color;
ctx.arc(x,-y,weight/2,0,Math.PI*2); ctx.fill();
}
else if(cmd==='cutcircle'){
const x=parseFloat(cmds[++i]),y=parseFloat(cmds[++i]),radius=parseFloat(cmds[++i]);
let angleICN=parseFloat(cmds[++i]),filledICN=parseFloat(cmds[++i]);
let circleAngle=(angleICN*10)-filledICN;
let oldX=x+Math.sin(circleAngle*Math.PI/180)*radius;
let oldY=-y-Math.cos(circleAngle*Math.PI/180)*radius;
const steps=Math.floor(filledICN/3)+1;
ctx.strokeStyle=color; ctx.lineWidth=weight;
for(let j=0;j<steps-1;j++){
circleAngle+=6;
const newX=x+Math.sin(circleAngle*Math.PI/180)*radius;
const newY=-y-Math.cos(circleAngle*Math.PI/180)*radius;
ctx.beginPath(); ctx.moveTo(oldX,oldY); ctx.lineTo(newX,newY); ctx.stroke();
oldX=newX; oldY=newY;
}
}
else if(cmd==='ellipse'){
const x=parseFloat(cmds[++i]),y=parseFloat(cmds[++i]),w=parseFloat(cmds[++i]),hm=parseFloat(cmds[++i]),dir=parseFloat(cmds[++i])*Math.PI/180;
ctx.save(); ctx.translate(x,-y); ctx.rotate(dir);
ctx.beginPath(); ctx.strokeStyle=color; ctx.lineWidth=weight;
ctx.scale(1,hm); ctx.arc(0,0,w/2,0,Math.PI*2); ctx.stroke(); ctx.restore();
}
}
ctx.restore();
}

const ta=document.getElementById('code');
const cv=document.getElementById('c');
document.getElementById('run').onclick=()=>renderICN(ta.value,cv);
document.getElementById('clear').onclick=()=>{ta.value=''; renderICN('',cv);};
renderICN(ta.value,cv);
</script>
</body>
</html>
